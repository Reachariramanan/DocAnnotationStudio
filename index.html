<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Image Annotation (Zoom + Right‐Pane Annotations)</title>
  <!-- Tailwind for utility classes -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Link to our external stylesheet -->
  <link rel="stylesheet" href="styles.css" />
</head>
<body class="bg-gray-100">
  <div class="container flex h-screen w-screen">
    <!-- ================================
         1) LEFT SIDEBAR: Image + Classes
         ================================ -->
    <div class="sidebar p-3 flex-none">
      <h2 class="text-lg font-bold mb-3">Image Annotation</h2>

      <!-- Image Selector -->
      <div class="mb-3">
        <label class="block text-sm font-medium mb-1">Select Image</label>
        <select id="imageSelect" class="w-full p-2 border rounded text-sm">
          <option value="">Loading…</option>
        </select>
      </div>
      <div id="loading" class="hidden text-gray-500 mb-3">Loading…</div>

      <!-- Class Management -->
      <div class="mb-4">
        <h3 class="text-md font-semibold mb-2">Annotation Classes</h3>
        <div class="mb-2">
          <input
            type="text"
            id="className"
            class="w-full p-2 border rounded mb-1 text-sm"
            placeholder="Class name"
          />
          <input
            type="color"
            id="classColor"
            class="w-full p-1 border rounded mb-1"
          />
          <button
            id="addClass"
            class="w-full bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
          >
            Add Class
          </button>
        </div>
        <ul id="classList" class="space-y-1"></ul>
      </div>
    </div>

    <!-- ================================
         2) RIGHT PANE: Canvas (left) + Annotations (right)
         ================================ -->
    <div class="rightPane flex-1 flex">
      <!-- 2a) Canvas Area (Zoom + Canvas) -->
      <div class="canvasArea flex-1 flex flex-col bg-gray-50">
        <!-- Zoom Toolbar -->
        <div class="toolbar flex items-center px-4 py-2 bg-white border-b">
          <label for="zoomSlider" class="mr-2 text-sm font-medium">Zoom:</label>
          <input
            type="range"
            id="zoomSlider"
            min="0.1"
            max="3"
            step="0.1"
            value="1"
            class="mr-2"
          />
          <span id="zoomValue" class="w-12 text-sm font-semibold">100%</span>

          <!-- Delete Selected Annotation (disabled until one is selected) -->
          <button
            id="deleteSelected"
            class="ml-2 bg-red-500 text-white rounded hover:bg-red-600 px-2 py-1 text-sm"
            disabled
          >
            Delete
          </button>

          <!-- Night Mode Toggle -->
          <button
            id="toggleNight"
            class="ml-auto bg-gray-200 text-black rounded hover:bg-gray-300 px-2 py-1 text-sm"
          >
            Night Mode
          </button>
        </div>

        <!-- Scrollable Canvas Container -->
        <div id="canvasContainer" class="flex-1 overflow-auto">
          <canvas id="canvas"></canvas>
        </div>
      </div>

      <!-- 2b) Annotations Panel -->
      <div class="annotationPanel w-64 border-l bg-white flex flex-col">
        <h3 class="p-2 text-md font-semibold border-b">Annotations</h3>
        <ul id="annotationList" class="flex-1 overflow-auto p-2 space-y-1"></ul>

        <!-- Edit Form (hidden until “Edit” clicked) -->
        <div id="editForm" class="hidden p-2 border-t">
          <h3 class="text-sm font-semibold mb-2">Edit Annotation</h3>
          <input
            type="text"
            id="editLabel"
            class="w-full p-2 border rounded mb-2 text-sm"
            placeholder="New label"
          />
          <select
            id="editClass"
            class="w-full p-2 border rounded mb-2 text-sm"
          >
            <option value="">Select class</option>
          </select>
          <div class="flex space-x-2">
            <button
              id="saveEdit"
              class="bg-green-500 text-white rounded hover:bg-green-600 px-3 text-sm"
            >
              Save
            </button>
            <button
              id="cancelEdit"
              class="bg-gray-500 text-white rounded hover:bg-gray-600 px-3 text-sm"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- =====================================
       JAVASCRIPT LOGIC
       ===================================== -->
  <script>
    /********************************************
     *  GLOBAL VARIABLES & DOM REFERENCES
     ********************************************/
    const imageSelect     = document.getElementById('imageSelect');
    const zoomSlider      = document.getElementById('zoomSlider');
    const zoomValue       = document.getElementById('zoomValue');
    const canvas          = document.getElementById('canvas');
    const ctx             = canvas.getContext('2d');
    const container       = document.getElementById('canvasContainer');
    const loading         = document.getElementById('loading');

    const classNameInput  = document.getElementById('className');
    const classColorInput = document.getElementById('classColor');
    const addClassButton  = document.getElementById('addClass');
    const classListUL     = document.getElementById('classList');

    const annotationListUL = document.getElementById('annotationList');
    const editForm        = document.getElementById('editForm');
    const editLabelInput  = document.getElementById('editLabel');
    const editClassSelect = document.getElementById('editClass');
    const saveEditButton  = document.getElementById('saveEdit');
    const cancelEditButton= document.getElementById('cancelEdit');

    const deleteSelectedBtn = document.getElementById('deleteSelected');
    const toggleNightBtn    = document.getElementById('toggleNight');

    /********************************************
     *  STATE VARIABLES
     ********************************************/
    let image = null;             // HTMLImageElement
    let zoom = 1;                 // 1 = 100%, range 0.1–3
    let isDrawing = false;        // true while dragging to draw
    let startXY = { x: 0, y: 0 }; // start of current drag (image‐coords)
    let currentRect = null;       // { x, y, width, height } while drawing

    // Each annotation: { id, x, y, width, height, label, classId, isDB }
    let annotations = [];

    // Classes: [ { id, name, color } ]
    let classes = [];

    // Which annotation is in edit mode?
    let editingId = null;

    // Which class is selected for new drawings?
    let selectedClass = null;

    // For moving annotations
    let movingAnn = null;          // the annotation object being moved (if any)
    let moveOffset = { x: 0, y: 0 }; // offset from mouse to ann.x/ann.y

    // For undo (Ctrl+Z)
    let historyStack = []; // each entry is a deep copy of “annotations”

    // For “delete selected” in top toolbar
    let selectedAnnotationId = null;

    /********************************************
     *  HELPERS: HISTORY / UNDO
     ********************************************/
    function pushHistory() {
      // Deep‐copy current annotations array
      const snapshot = annotations.map(ann => ({ ...ann }));
      historyStack.push(snapshot);
      if (historyStack.length > 50) historyStack.shift();
    }

    function undo() {
      if (historyStack.length === 0) return;
      const prev = historyStack.pop();
      annotations = prev.map(ann => ({ ...ann }));
      selectedAnnotationId = null;
      deleteSelectedBtn.disabled = true;
      updateAnnotationListUI();
      redrawCanvas();
    }

    /********************************************
     *  HELPERS: FIND ANNOTATION UNDER A POINT
     ********************************************/
    function findAnnotationAt(imgX, imgY) {
      // Return the topmost annotation whose bounds contain (imgX, imgY)
      for (let i = annotations.length - 1; i >= 0; i--) {
        const ann = annotations[i];
        if (
          imgX >= ann.x &&
          imgX <= ann.x + ann.width &&
          imgY >= ann.y &&
          imgY <= ann.y + ann.height
        ) {
          return ann;
        }
      }
      return null;
    }

    /********************************************
     *  1) LOAD IMAGE LIST (WITH OCR ANNOTATIONS)
     ********************************************/
    async function loadImages() {
      try {
        loading.classList.remove('hidden');
        const resp = await fetch('/api/images');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const images = await resp.json();
        imageSelect.innerHTML = '<option value="">-- Select an image --</option>';
        images.forEach(imgObj => {
          const fileName = imgObj.file.split('/').pop();
          const opt = document.createElement('option');
          opt.value = imgObj.file;
          opt.textContent = fileName;
          imageSelect.appendChild(opt);
        });
        if (images.length === 0) {
          imageSelect.innerHTML = '<option value="">(No images found)</option>';
        }
      } catch (err) {
        console.error('Error loading images:', err);
        imageSelect.innerHTML = '<option value="">Failed to load</option>';
      } finally {
        loading.classList.add('hidden');
      }
    }

    /********************************************
     *  2) LOAD CLASSES FROM DATABASE
     ********************************************/
    async function loadClasses() {
      try {
        const resp = await fetch('/api/classes');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        classes = await resp.json();
        updateClassListUI();
      } catch (err) {
        console.error('Error loading classes:', err.message);
        classListUL.innerHTML =
          '<p class="text-red-500 text-sm">Failed to load classes</p>';
      }
    }

    /********************************************
     *  3) UPDATE CLASS LIST PANEL
     ********************************************/
    function updateClassListUI() {
      classListUL.innerHTML = '';
      editClassSelect.innerHTML = '<option value="">Select class</option>';
      classes.forEach(cls => {
        const li = document.createElement('li');
        li.className = 'class-item border rounded flex items-center p-2';
        li.innerHTML = `
          <span
            class="color-box mr-2"
            style="background-color: ${cls.color}"
          ></span>
          <span class="text-sm">${cls.name}</span>
          <button
            onclick="selectClass('${cls.id}')"
            class="ml-auto bg-blue-500 text-white rounded hover:bg-blue-600 px-2 text-sm"
          >
            Select
          </button>
        `;
        classListUL.appendChild(li);

        const opt = document.createElement('option');
        opt.value = cls.id;
        opt.textContent = cls.name;
        editClassSelect.appendChild(opt);
      });
    }

    /********************************************
     *  4) SELECT A CLASS FOR NEW ANNOTATIONS
     ********************************************/
    window.selectClass = (id) => {
      selectedClass = classes.find(c => c.id === id);
      document.querySelectorAll('#classList button').forEach(btn => {
        btn.classList.remove('bg-green-500', 'hover:bg-green-600');
        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
      });
      const chosenBtn = document.querySelector(`button[onclick="selectClass('${id}')"]`);
      if (chosenBtn) {
        chosenBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
        chosenBtn.classList.add('bg-green-500', 'hover:bg-green-600');
      }
    };

    /********************************************
     *  5) ADD NEW CLASS (POST TO /api/classes)
     ********************************************/
    addClassButton.addEventListener('click', async () => {
      const name = classNameInput.value.trim();
      const color = classColorInput.value;
      if (!name || !color) {
        alert('Please enter a class name and choose a color');
        return;
      }
      try {
        const resp = await fetch('/api/classes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, color })
        });
        if (!resp.ok) throw new Error('Failed to save class');
        const newCls = await resp.json();
        classes.push(newCls);
        updateClassListUI();
        classNameInput.value = '';
        classColorInput.value = '#000000';
      } catch (err) {
        console.error('Error saving class:', err.message);
        alert('Failed to save class: ' + err.message);
      }
    });

    /********************************************
     *  6) IMAGE SELECTION HANDLER
     ********************************************/
    imageSelect.addEventListener('change', async () => {
      const file = imageSelect.value;
      if (!file) {
        image = null;
        annotations = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        selectedAnnotationId = null;
        deleteSelectedBtn.disabled = true;
        updateAnnotationListUI();
        return;
      }

      // Reset zoom to 100%
      zoom = 1;
      zoomSlider.value = '1';
      zoomValue.textContent = '100%';
      canvas.style.transform = `scale(${zoom})`;

      try {
        loading.classList.remove('hidden');
        const resp = await fetch('/api/images');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const images = await resp.json();
        const chosenObj = images.find(obj => obj.file === file);
        if (!chosenObj) {
          throw new Error('Image metadata not found');
        }

        // Load the image at its full resolution
        image = new Image();
        image.onload = () => {
          canvas.width = image.naturalWidth;
          canvas.height = image.naturalHeight;

          // Build the annotations array from OCR results (isDB=true)
          annotations = chosenObj.annotations
            ? chosenObj.annotations.map(ann => ({
                id: ann.id,
                x: ann.x,
                y: ann.y,
                width: ann.width,
                height: ann.height,
                label: ann.label || '',
                classId: null,
                isDB: true
              }))
            : [];
          selectedAnnotationId = null;
          deleteSelectedBtn.disabled = true;
          updateAnnotationListUI();
          redrawCanvas();
          // Debug: Log annotationPanel dimensions
          const panel = document.querySelector('.annotationPanel');
          console.log('Annotation Panel:', {
            width: panel.offsetWidth,
            height: panel.offsetHeight,
            display: window.getComputedStyle(panel).display
          });
        };
        image.onerror = () => {
          console.error(`Failed to load image: ${file}`);
          image = null;
          annotations = [];
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          selectedAnnotationId = null;
          deleteSelectedBtn.disabled = true;
          updateAnnotationListUI();
        };
        image.src = '/' + file;
      } catch (err) {
        console.error('Error loading image:', err.message);
        image = null;
        annotations = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        selectedAnnotationId = null;
        deleteSelectedBtn.disabled = true;
        updateAnnotationListUI();
        alert('Failed to load image or annotations: ' + err.message);
      } finally {
        loading.classList.add('hidden');
      }
    });

    /********************************************
     *  7) ZOOM SLIDER HANDLER
     ********************************************/
    zoomSlider.addEventListener('input', () => {
      zoom = parseFloat(zoomSlider.value);
      const percent = Math.round(zoom * 100);
      zoomValue.textContent = percent + '%';
      canvas.style.transformOrigin = '0 0';
      canvas.style.transform = `scale(${zoom})`;
    });

    /********************************************
     *  8) DRAWING: Mouse Events on Canvas
     ********************************************/
    canvas.addEventListener('mousedown', (e) => {
      if (!image) return;
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / zoom;
      const y = (e.clientY - rect.top) / zoom;
      startXY = { x, y };
      currentRect = { x, y, width: 0, height: 0 };
    });

    canvas.addEventListener('mousemove', (e) => {
      // If moving an annotation, adjust its position instead of drawing
      if (movingAnn && image) {
        const rect = canvas.getBoundingClientRect();
        const imgX = (e.clientX - rect.left) / zoom;
        const imgY = (e.clientY - rect.top) / zoom;

        movingAnn.x = imgX - moveOffset.x;
        movingAnn.y = imgY - moveOffset.y;

        // Clamp within image bounds
        if (movingAnn.x < 0) movingAnn.x = 0;
        if (movingAnn.y < 0) movingAnn.y = 0;
        if (movingAnn.x + movingAnn.width > image.naturalWidth) {
          movingAnn.x = image.naturalWidth - movingAnn.width;
        }
        if (movingAnn.y + movingAnn.height > image.naturalHeight) {
          movingAnn.y = image.naturalHeight - movingAnn.height;
        }

        redrawCanvas();
        return;
      }

      // Normal drawing
      if (!isDrawing || !image) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / zoom;
      const y = (e.clientY - rect.top) / zoom;
      currentRect = {
        x: Math.min(startXY.x, x),
        y: Math.min(startXY.y, y),
        width: Math.abs(x - startXY.x),
        height: Math.abs(y - startXY.y)
      };
      redrawCanvas();
    });

    canvas.addEventListener('mouseup', () => {
      if (!isDrawing || !image) return;
      isDrawing = false;
      if (currentRect.width > 5 && currentRect.height > 5) {
        // RECORD STATE FOR UNDO
        pushHistory();

        const label = prompt('Enter label for this annotation:') || '';
        const id = `user_${Date.now()}`;
        annotations.push({
          id,
          x: currentRect.x,
          y: currentRect.y,
          width: currentRect.width,
          height: currentRect.height,
          label,
          classId: selectedClass ? selectedClass.id : null,
          isDB: false
        });
        selectedAnnotationId = null;
        deleteSelectedBtn.disabled = true;
        updateAnnotationListUI();
      }
      currentRect = null;
      redrawCanvas();
    });

    /********************************************
     *  9) DRAW/REDRAW CANVAS (IMAGE + ALL ANNOTATIONS)
     ********************************************/
    function redrawCanvas() {
      if (!image) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      // 1) Draw base image
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);

      // 2) Draw saved annotations
      annotations.forEach(ann => {
        // decide color
        let color = '#00FF00';
        if (ann.isDB) {
          color = '#FF0000';
        } else if (ann.classId) {
          const cls = classes.find(c => c.id === ann.classId);
          if (cls) color = cls.color;
        }
        // draw rect
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(ann.x, ann.y, ann.width, ann.height);
        ctx.fillStyle = color + '33';
        ctx.fillRect(ann.x, ann.y, ann.width, ann.height);

        // draw label with word‐wrap
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        const maxW = 200;
        const words = (ann.label || '').split(' ');
        let line = '';
        let yOff = ann.y - 16;
        words.forEach(w => {
          const testLine = line + w + ' ';
          const m = ctx.measureText(testLine);
          if (m.width > maxW && line) {
            ctx.fillText(line, ann.x, yOff);
            line = w + ' ';
            yOff += 16;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, ann.x, yOff);
      });

      // 3) If drawing a new rect, draw it in blue
      if (currentRect) {
        ctx.strokeStyle = '#0000FF';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          currentRect.x,
          currentRect.y,
          currentRect.width,
          currentRect.height
        );
        ctx.fillStyle = '#0000FF33';
        ctx.fillRect(
          currentRect.x,
          currentRect.y,
          currentRect.width,
          currentRect.height
        );
      }
    }

    /********************************************
     *  10) UPDATE ANNOTATION LIST (RIGHT PANEL)
     ********************************************/
    function updateAnnotationListUI() {
      annotationListUL.innerHTML = '';
      if (annotations.length === 0) {
        annotationListUL.innerHTML =
          '<p class="text-gray-500 text-sm">No annotations yet.</p>';
        selectedAnnotationId = null;
        deleteSelectedBtn.disabled = true;
        return;
      }
      annotations.forEach(ann => {
        const cls = classes.find(c => c.id === ann.classId);
        const colorBox = ann.isDB
          ? '#FF0000'
          : (cls ? cls.color : '#00FF00');
        const li = document.createElement('li');
        li.className = 'border rounded p-2 flex flex-col bg-gray-50';

        // Highlight if selected
        if (ann.id === selectedAnnotationId) {
          li.style.border = '2px solid #FFAA00';
          li.style.backgroundColor = '#FEF8E7';
        }

        li.innerHTML = `
          <div class="flex items-center mb-1">
            <span class="w-3 h-3 mr-2" style="background-color: ${colorBox}; border:1px solid #000;"></span>
            <strong class="text-sm flex-1">Label:</strong>
            <span class="text-sm ml-1">${ann.label || 'No label'}</span>
          </div>
          <div class="flex items-center mb-1">
            <strong class="text-sm">Class:</strong>
            <span class="text-sm ml-1">${cls ? cls.name : (ann.isDB ? '[OCR]' : 'None')}</span>
          </div>
          <div class="flex items-center mb-1">
            <strong class="text-sm">Pos:</strong>
            <span class="text-sm ml-1">(${Math.round(ann.x)}, ${Math.round(ann.y)})</span>
          </div>
          <div class="flex items-center mb-1">
            <strong class="text-sm">Size:</strong>
            <span class="text-sm ml-1">${Math.round(ann.width)}×${Math.round(ann.height)}</span>
          </div>
          <div class="flex space-x-2 mt-1">
            <button onclick="editAnnotation('${ann.id}')"
                    class="flex-1 bg-blue-500 text-white rounded hover:bg-blue-600 px-2 py-0.5 text-sm">
              Edit
            </button>
            <button onclick="deleteAnnotation('${ann.id}')"
                    class="flex-1 bg-red-500 text-white rounded hover:bg-red-600 px-2 py-0.5 text-sm">
              Del
            </button>
          </div>
        `;

        // Select on click (but avoid inner buttons)
        li.addEventListener('click', (evt) => {
          if (evt.target.tagName.toLowerCase() === 'button') return;
          selectedAnnotationId = ann.id;
          deleteSelectedBtn.disabled = false;
          updateAnnotationListUI();
        });

        annotationListUL.appendChild(li);
      });
    }

    /********************************************
     *  11) EDIT / DELETE HANDLERS
     ********************************************/
    window.editAnnotation = (id) => {
      const ann = annotations.find(a => a.id === id);
      if (!ann) return;
      editingId = id;
      editLabelInput.value = ann.label;
      editClassSelect.value = ann.classId || '';
      editForm.classList.remove('hidden');
    };

    saveEditButton.addEventListener('click', () => {
      pushHistory();
      annotations = annotations.map(ann =>
        ann.id === editingId
          ? { ...ann,
              label: editLabelInput.value,
              classId: editClassSelect.value || null
            }
          : ann
      );
      editingId = null;
      editForm.classList.add('hidden');
      updateAnnotationListUI();
      redrawCanvas();
    });

    cancelEditButton.addEventListener('click', () => {
      editingId = null;
      editForm.classList.add('hidden');
    });

    window.deleteAnnotation = (id) => {
      pushHistory();
      annotations = annotations.filter(ann => ann.id !== id);
      if (selectedAnnotationId === id) {
        selectedAnnotationId = null;
        deleteSelectedBtn.disabled = true;
      }
      updateAnnotationListUI();
      redrawCanvas();
    };

    // Delete from top toolbar
    deleteSelectedBtn.addEventListener('click', () => {
      if (!selectedAnnotationId) return;
      pushHistory();
      annotations = annotations.filter(ann => ann.id !== selectedAnnotationId);
      selectedAnnotationId = null;
      deleteSelectedBtn.disabled = true;
      updateAnnotationListUI();
      redrawCanvas();
    });

    /********************************************
     *  12) MOVE ANNOTATION: dblclick + drag
     ********************************************/
    canvas.addEventListener('dblclick', (e) => {
      if (!image) return;

      const rect = canvas.getBoundingClientRect();
      const imgX = (e.clientX - rect.left) / zoom;
      const imgY = (e.clientY - rect.top) / zoom;

      const ann = findAnnotationAt(imgX, imgY);
      if (!ann) return;

      // RECORD STATE FOR UNDO
      pushHistory();

      movingAnn = ann;
      moveOffset.x = imgX - ann.x;
      moveOffset.y = imgY - ann.y;
    });

    // Window mouseup completes any ongoing move
    window.addEventListener('mouseup', () => {
      if (movingAnn) {
        movingAnn = null;
        updateAnnotationListUI();
        redrawCanvas();
      }
    });

    /********************************************
     *  13) UNDO: Listen for Ctrl+Z
     ********************************************/
    window.addEventListener('keydown', (e) => {
      if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
        e.preventDefault();
        undo();
      }
    });

    /********************************************
     *  14) NIGHT-MODE TOGGLE
     ********************************************/
    toggleNightBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        toggleNightBtn.textContent = 'Light Mode';
      } else {
        toggleNightBtn.textContent = 'Night Mode';
      }
    });

    /********************************************
     *  15) INITIALIZATION
     ********************************************/
    // Ensure canvas container can scroll/pan when zoomed
    container.style.overflow = 'auto';

    // Kick off the two loads
    loadImages();
    loadClasses();
  </script>
</body>
</html>
